# vim: ft=sh

# This part of the script is meant to be POSIX compliant

# Shell is non-interactive. Be done now
# [[ $- != *i* ]] && return
echo "$-" | grep i >/dev/null || return

if [ -z "$HOME" ] || ! [ -d "$HOME" ]; then
	echo "HOME is not defined or not a real folder. Please set it to a valid value"
	return
fi

# Reset PATH to a somewhat standard value
export PATH="/bin:/sbin:/usr/bin:/usr/sbin:$PATH"

# use strict (cannot work with third party modules badly written...)
#set -u

# Configuration
MYSHELL_HUB="https://github.com/saruspete/myshell.git"
MYSHELL_DIR="$HOME/.myshell"
MYSHELL_LIB="$MYSHELL_DIR/lib"   # Shell env to be loaded
MYSHELL_BIN="$MYSHELL_DIR/bin"   # Local bin
MYSHELL_EXT="$MYSHELL_DIR/home"  # Home data to be merged
MYSHELL_LOC="$MYSHELL_DIR/local" # Local modifications
MYSHELL_RUN="$MYSHELL_DIR/run"   # Cache
MYSHELL_LCK="$MYSHELL_DIR/.initialized"

# #####################################
# Helper subs

mys_date () {
	date +'%Y-%m-%d_%H-%M-%S'
}

mys_merge () {
	dir="$1"
	src="$2"
	name="${src##*/}"
	dst="$dir/$name"

	if [ -L "$dst" ]; then
		echo "MyShell: cannot merge '$src' with '$dst': Target is a symlink"
		return 1
	fi

	# If target file exists, try to merge files
	if [ -e "$dst" ]; then
		# Prepare the merge
		loc="$MYSHELL_LOC/$name"
		cp -a "$dst" "$loc"

		# Backup local and clear destination
		mv "$dst" "${dst}.mys.$(mys_date)"

		# Try to merge if file
		if [ -f "$loc" ]; then
			cat "$src" >> "$loc"
			src="$loc"
		fi
	fi

	# Symlink to source
	ln -s "${src#$dir/}" "$dst"
}

mys_isavail () {
	type $1 >/dev/null 2>&1
}

# update from origin
mys_update () {
	if ! mys_isavail "git"; then
		echo "You need git to update MyShell automatically"
		return 1
	fi

	if [ -e "$MYSHELL_DIR/.git" ]; then
		git -C "$MYSHELL_DIR" pull
	else
		git clone "$MYSHELL_HUB" "$MYSHELL_DIR"
	fi
}

# sync and send to another local hosts
mys_sync () {
	typeset hosts="$@"
	for h in $hosts; do
		echo "MyShell: Syncing $h"
		ssh $h 2>/dev/null <<-EOT
		[ -e $HOME/.myshell ] || mkdir "$HOME/.myshell"
		for i in $HOME/{.bashrc,.profile}; do
			[ -e "$i" ] || ln -s .myshell/myshell $i
		done 
		EOT
		rsync -a "$MYSHELL_DIR/" $h:
	done
}

mys_reload () {
	. "$MYSHELL_DIR/myshell"
}

# Load
mys_loadmod () {
	mod="$1"
	val="$2"

	[ -z "$val" ] && return
	for file in $MYSHELL_LIB/by_$mod/$val; do
		[ -e "$file" ] || continue
		. "$file"
	done
}

# 
mys_cacherun () {
	name="$1"; shift

	if [ -z "$name" ] || [ -z "$@" ]; then
		echo "MyShell: Usage: mys_cacherun <name> <command>" >&2
		return 1
	fi

	date="$(mys_date)"
	cachepath="$MYSHELL_RUN/cache/${name}/"
	[ -d "$cachepath" ] || mkdir -p "$cachepath"
	cachefile="$cachepath/$date"

	# Get start time, execute the command, write metadata, write output
	start="$(mys_date)"
	result="$($@)"
	rescode="$?"
	echo -n "'$@' # \$?=$rescode # $start # $(mys_date)" >| "$cachefile.meta"
	echo "$result" | tee "$cachefile.out"
	# Set it as the last file
	ln -sf "${cachefile}.out"  "${cachepath}/last.out"
	ln -sf "${cachefile}.meta" "${cachepath}/last.meta"
	# And return command result
	return $rescode
}

mys_cachelist () {
	name="$1"

	[ -z "$name" ] && {
		echo "MyShell: Usage: mys_cachelist <name>" >&2
		return 1
	}

	cachepath="$MYSHELL_RUN/cache/$name/"
	for out in $cachepath/*.out; do
		[ ! -e "$out" ] && continue
		echo "${out##*/}  ( $(cat ${out%.out}.meta) )"
	done
}

mys_cacheget () {
	name="$1"
	vers="${2:-last}"

	if [ -z "$name" ]; then
		echo "MyShell: Usage: mys_cacheget <name> [version]" >&2
		return 1
	fi

	cachepath="$MYSHELL_RUN/cache/$name"
	if ! [ -e "${cachepath}/${vers}.out" ]; then
		echo "MyShell: No version of '$name' matches '$vers'" >&2
		return 2
	fi
	# Output the file
	cat "$cachepath/${vers}.out"
}

mys_cacheclear () {
	:
}

# #####################################
# Environement management

mys_path_binadd () {
	mys_path_add "PATH" $@
}

mys_path_manadd () {
	mys_path_add "MANPATH" $@
}

mys_path_libadd () {
	mys_path_add "LB_LIBRARY_PATH" $@
}


mys_path_add () {
	var="$1"; shift
	where="$1"
	if [ "$where" = "before" ] || [ "$where" = "after" ]; then
		shift
	fi

	for newpath in "$@"; do
		OIFS="$IFS"
		IFS=":"
		for p in $PATH; do
			[ "$newpath" = "$p" ] && {
				IFS="$OIFS"
				continue 2
			}
		done
		IFS="$OIFS"
		# Where to add the path
		if [ "$where" = "before" ]; then
			eval export $var="$newpath:\$$var"
		else
			eval export $var="\$$var:$newpath"
		fi
	done

}

mys_setopt () {
	if mys_isavail shopt; then
		shopt $@
	elif mys_isavail setopt; then
		setopt $@
	else
		echo "MyShell: Fatal error: shopt nor setopt are available. What shell are you using ?"
		return 1
	fi
}


# That should be a typeset -i but POSIX...
MYS_LOADTIME="$(date +%s)"
mys_promptfunc () {
	# Reload configuration if witness flag is present
	if [ -s "$MYSHELL_DIR/.reload" ]; then
		time="$(cat $MYSHELL_DIR/.reload | tr -cd '[0-9]')"
		[ "${time:-0}" -gt "$MYS_LOADTIME" ] && mys_reload
	fi

	# Do extended tests if needed.
}
PROMPT_COMMAND="mys_promptfunc"



# #####################################
# Main processing

# Load external configuration files
if ! [ -e "$MYSHELL_LCK" ]; then
	echo "MyShell: Initializing local configuration files"
	src=""
	mys_setopt -s dotglob
	for src in $MYSHELL_EXT/*; do
		[ -e "$src" ] || continue

		echo "MyShell: Merging $src in $HOME"
		mys_merge "$HOME" "$src"
	done
	mys_setopt -u dotglob

	date +'%y%m%d_%H%M%S' >| "$MYSHELL_LCK"
fi

# Add custom binaries to PATH
mys_path_binadd "$MYSHELL_BIN"

# Domains
mys_hostname="$(uname -n)"
mys_hostfqdn="$(getent hosts $mys_hostname|awk 'END{print $2}')"
mys_hostdom="${mys_hostfqdn#*.}"
if [ "$mys_hostdom" = "$mys_hostfqdn" ]; then
	mys_hostdom=""
fi


# Try to guess our running env (chroot, jail, VM...)
MYS_RUNENV=""
if [ -e /proc/1/mountinfo ]; then
	if [ "$(awk '$5=="/"{print $4}' /proc/1/mountinfo)" != "/" ]; then
		#if [[ -d "/sys/fs/cgroup/memory/lxc/$mys_hostname*" ]]; then
		if grep "/lxc/$mys_hostname" /proc/1/cgroup >/dev/null 2>&1 || \
		   grep "container=lxc" /proc/1/environ >/dev/null 2>&1; then
			MYS_RUNENV="lxc"
		elif grep "/docker/" /proc/1/cgroup >/dev/null 2>&1; then
			MYS_RUNENV="docker"
		else
			MYS_RUNENV="chroot"
		fi
	fi
fi


# Load per-shell definitions
mys_shellname="${0##*/}"
mys_shellname="${mys_shellname#-}"
mys_custom="$MYSHELL_DIR/myshell.${mys_shellname}"
if [ -e "$mys_custom" ]; then
	. "$mys_custom"
else
	echo "MyShell: No custom file found for shell '$0'"
fi

# Load custom modules
mys_loadmod "default" "*"
mys_loadmod "os" "$(uname -s)"
mys_loadmod "os" "$(uname -s).priv"
mys_loadmod "shell" "$mys_shellname"
mys_loadmod "shell" "$mys_shellname.priv"
mys_loadmod "domain" "$mys_hostdom"
mys_loadmod "domain" "$mys_hostdom.priv"
mys_loadmod "host" "$mys_hostname"
mys_loadmod "host" "$mys_hostname.priv"
mys_loadmod "user" "$(id -nu)"
mys_loadmod "user" "$(id -nu).priv"

